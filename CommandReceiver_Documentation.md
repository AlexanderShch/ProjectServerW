# Документация: Модуль приема и обработки команд от сервера

**Проект:** Defrost Control System  
**Модуль:** CommandReceiver  
**Версия:** 1.0.0  
**Дата:** 24 октября 2025  

---

## Содержание

1. [Общее описание](#общее-описание)
2. [Архитектура модуля](#архитектура-модуля)
3. [Протокол обмена данными](#протокол-обмена-данными)
4. [Типы команд](#типы-команд)
5. [Формат пакета данных](#формат-пакета-данных)
6. [API функций](#api-функций)
7. [Примеры использования](#примеры-использования)
8. [Обработка ошибок](#обработка-ошибок)
9. [Конфигурация](#конфигурация)

---

## Общее описание

Модуль **CommandReceiver** предназначен для приема и обработки команд от удаленного сервера через интерфейс UART (COM-порт). Модуль работает в составе системы управления дефростером на базе микроконтроллера STM32F429.

### Основные функции:

- Прием команд от сервера через UART4 в асинхронном режиме
- Проверка целостности данных с использованием CRC16
- Обработка различных типов команд (управление, конфигурация, запросы)
- Отправка ответов и подтверждений серверу
- Сбор статистики работы модуля

### Используемые ресурсы:

- **UART4** - для связи с сервером
- **Семафоры RTOS:**
  - `PR_RX_Compl_SemHandle` - завершение приема
  - `PR_TX_Compl_SemHandle` - завершение передачи
- **GPIO:** PROG_MASTER_DE - управление направлением передачи (RS-485)
- **DMA** - для асинхронной передачи/приема данных

---

## Архитектура модуля

### Структура модуля

```
CommandReceiver/
├── CommandReceiver.hpp    - Заголовочный файл с определениями
└── CommandReceiver.cpp    - Реализация функций
```

### Основные компоненты:

1. **Задача приема команд** (`CommandReceiver_Task`)
   - Бесконечный цикл приема данных
   - Парсинг входящих пакетов
   - Проверка CRC
   - Маршрутизация команд

2. **Обработчики команд**
   - `CommandReceiver_HandleProgControl` - управление программой
   - `CommandReceiver_HandleDeviceControl` - управление устройствами
   - `CommandReceiver_HandleConfiguration` - конфигурация системы
   - `CommandReceiver_HandleRequest` - обработка запросов данных

3. **Модуль отправки ответов**
   - `CommandReceiver_SendResponse` - формирование и отправка ответа

4. **Вспомогательные функции**
   - `CommandReceiver_CalculateCRC` - вычисление CRC16
   - `CommandReceiver_ValidateCRC` - проверка CRC16

### Диаграмма работы

```
┌─────────────┐
│   Сервер    │
└──────┬──────┘
       │ UART4 (RS-485)
       ▼
┌─────────────────────────────────────┐
│  CommandReceiver_Task               │
│  ┌───────────────────────────────┐  │
│  │ 1. Прием данных (DMA)         │  │
│  │ 2. Парсинг пакета             │  │
│  │ 3. Проверка CRC               │  │
│  └───────────────┬───────────────┘  │
│                  ▼                  │
│  ┌───────────────────────────────┐  │
│  │ Маршрутизация по типу команды │  │
│  └───┬───────────────────────┬───┘  │
│      │                       │      │
│      ▼                       ▼      │
│  ┌──────────┐           ┌──────────┐│
│  │Обработчик│    ...    │Обработчик││
│  └────┬─────┘           └────┬─────┘│
│       │                      │      │
│       └──────────┬───────────┘      │
│                  ▼                  │
│  ┌───────────────────────────────┐  │
│  │ Отправка ответа               │  │
│  └───────────────────────────────┘  │
└────────────────┬────────────────────┘
                 │
                 ▼
          ┌─────────────┐
          │  Устройства │
          │  (DFR, реле)│
          └─────────────┘
```

---

## Протокол обмена данными

### Параметры UART

- **Скорость:** 19200 бод (по умолчанию, настраивается)
- **Биты данных:** 8
- **Стоп-биты:** 1
- **Четность:** Нет
- **Контроль потока:** RS-485 (управление DE через GPIO)

### Механизм обмена

1. Сервер отправляет команду
2. Контроллер принимает команду по событию IDLE
3. Проверяется CRC
4. Выполняется команда
5. Отправляется ответ (для большинства команд)

### Тайминги

- **Таймаут приема:** 5000 мс
- **Таймаут передачи:** 100 мс
- **Задержка переключения DE:** 1 мс

---

## Типы команд

### 1. Команды управления программой (PROG_CONTROL = 0x01)

| Код  | Название       | Описание                        | Данные |
|------|----------------|---------------------------------|--------|
| 0x01 | START          | Запуск программы (авто режим)   | Нет    |
| 0x02 | STOP           | Остановка программы             | Нет    |
| 0x03 | PAUSE          | Приостановка программы          | Нет    |
| 0x04 | RESUME         | Возобновление программы         | Нет    |
| 0x05 | RESET          | Сброс программы                 | Нет    |

**Действия:**
- START: Переключает систему в автоматический режим
- STOP: Переключает в ручной режим и выключает все устройства
- PAUSE: Сохраняет состояние и деактивирует устройства
- RESUME: Восстанавливает автоматический режим

### 2. Команды управления устройствами (DEVICE_CONTROL = 0x04)

| Код  | Название       | Описание                      | Данные           |
|------|----------------|-------------------------------|------------------|
| 0x01 | RELAY_ON       | Включить реле                 | 1 байт - номер   |
| 0x02 | RELAY_OFF      | Выключить реле                | 1 байт - номер   |
| 0x03 | RELAY_SET      | Установить состояние реле     | 2 байта - маска  |
| 0x04 | HEATER_ON      | Включить все нагреватели      | Нет              |
| 0x05 | HEATER_OFF     | Выключить все нагреватели     | Нет              |
| 0x06 | FAN_ON         | Включить все вентиляторы      | Нет              |
| 0x07 | FAN_OFF        | Выключить все вентиляторы     | Нет              |

**Примечания:**
- Номер реле: 0-15
- Битовая маска для RELAY_SET: бит 0 = реле 0, бит 15 = реле 15
- Все команды переключают систему в ручной режим

### 3. Команды конфигурации (CONFIGURATION = 0x02)

| Код  | Название          | Описание                    | Данные                |
|------|-------------------|-----------------------------|-----------------------|
| 0x01 | SET_TEMPERATURE   | Установить целевую T°       | 4 байта (float)       |
| 0x02 | SET_INTERVAL      | Установить интервал измер.  | 2 байта (uint16)      |
| 0x03 | SET_MODE          | Установить режим работы     | 1 байт (0=авто, 1=ручн)|

### 4. Команды запроса данных (REQUEST = 0x03)

| Код  | Название       | Описание                        | Ответ                    |
|------|----------------|---------------------------------|--------------------------|
| 0x01 | GET_STATUS     | Запросить текущий статус        | 2 байта - регистр DFR    |
| 0x02 | GET_VERSION    | Запросить версию прошивки       | Строка версии            |
| 0x03 | GET_CONFIG     | Запросить текущую конфигурацию  | 1 байт - режим работы    |

---

## Формат пакета данных

### Структура команды (от сервера к контроллеру)

```
┌──────────┬──────────┬───────────┬──────────┬─────────┐
│  Байт 0  │  Байт 1  │  Байт 2   │ Байт 3-N │ N+1, N+2│
├──────────┼──────────┼───────────┼──────────┼─────────┤
│   Type   │   Code   │  DataLen  │   Data   │  CRC16  │
│ (1 байт) │ (1 байт) │  (1 байт) │(0-59 б.) │(2 байта)│
└──────────┴──────────┴───────────┴──────────┴─────────┘
```

**Поля:**
- **Type** - тип команды (PROG_CONTROL, DEVICE_CONTROL, и т.д.)
- **Code** - код команды в рамках типа
- **DataLen** - длина поля данных (0-59)
- **Data** - данные команды (опционально)
- **CRC16** - контрольная сумма (ModBus CRC16), младший байт первый

**Максимальная длина:** 64 байта

### Структура ответа (от контроллера к серверу)

```
┌──────────┬──────────┬──────────┬───────────┬──────────┬─────────┐
│  Байт 0  │  Байт 1  │  Байт 2  │  Байт 3   │ Байт 4-N │ N+1, N+2│
├──────────┼──────────┼──────────┼───────────┼──────────┼─────────┤
│   Type   │   Code   │  Status  │  DataLen  │   Data   │  CRC16  │
│ (1 байт) │ (1 байт) │ (1 байт) │  (1 байт) │(0-59 б.) │(2 байта)│
└──────────┴──────────┴──────────┴───────────┴──────────┴─────────┘
```

**Поля:**
- **Type** - тип исходной команды
- **Code** - код исходной команды
- **Status** - статус выполнения команды
- **DataLen** - длина поля данных ответа
- **Data** - данные ответа (опционально)
- **CRC16** - контрольная сумма (ModBus CRC16)

### Коды статуса выполнения

| Код  | Название              | Описание                           |
|------|-----------------------|------------------------------------|
| 0x00 | CMD_STATUS_OK         | Команда выполнена успешно          |
| 0x01 | CMD_STATUS_CRC_ERROR  | Ошибка контрольной суммы           |
| 0x02 | CMD_STATUS_INVALID_TYPE| Неизвестный тип команды           |
| 0x03 | CMD_STATUS_INVALID_CODE| Неизвестный код команды           |
| 0x04 | CMD_STATUS_INVALID_LENGTH| Неверная длина данных          |
| 0x05 | CMD_STATUS_EXECUTION_ERROR| Ошибка выполнения команды    |
| 0x06 | CMD_STATUS_TIMEOUT    | Таймаут выполнения                 |
| 0xFF | CMD_STATUS_UNKNOWN_ERROR| Неизвестная ошибка              |

---

## Описание API функций

### Основные функции

#### `void CommandReceiver_Init(void)`

**Описание:** Инициализация модуля приема команд

**Параметры:** Нет

**Возвращает:** Ничего

**Использование:**
```cpp
CommandReceiver_Init();
```

---

#### `void CommandReceiver_Task(void *argument)`

**Описание:** Основная задача приема команд (работает в бесконечном цикле)

**Параметры:**
- `argument` - параметр задачи RTOS (не используется)

**Возвращает:** Ничего

**Примечание:** Запускается как отдельная задача FreeRTOS

---

#### `CommandStatus_t CommandReceiver_ProcessCommand(Command_t *cmd)`

**Описание:** Обработка полученной команды

**Параметры:**
- `cmd` - указатель на структуру команды

**Возвращает:** Статус выполнения команды (CommandStatus_t)

**Использование:**
```cpp
Command_t receivedCommand;
// ... заполнение структуры ...
CommandStatus_t status = CommandReceiver_ProcessCommand(&receivedCommand);
if (status == CMD_STATUS_OK) {
    // Команда выполнена успешно
}
```

---

#### `void CommandReceiver_SendResponse(CommandResponse_t *response)`

**Описание:** Отправка ответа на команду серверу

**Параметры:**
- `response` - указатель на структуру ответа

**Возвращает:** Ничего

**Использование:**
```cpp
CommandResponse_t response;
response.commandType = CMD_TYPE_RESPONSE;
response.commandCode = 0x01;
response.status = CMD_STATUS_OK;
response.dataLength = 0;
CommandReceiver_SendResponse(&response);
```

---

### Обработчики команд

#### `CommandStatus_t CommandReceiver_HandleProgControl(Command_t *cmd)`

**Описание:** Обработчик команд управления программой

**Параметры:**
- `cmd` - указатель на команду

**Возвращает:** Статус выполнения

**Поддерживаемые коды:** START, STOP, PAUSE, RESUME, RESET

---

#### `CommandStatus_t CommandReceiver_HandleDeviceControl(Command_t *cmd)`

**Описание:** Обработчик команд управления устройствами

**Параметры:**
- `cmd` - указатель на команду

**Возвращает:** Статус выполнения

**Поддерживаемые коды:** RELAY_ON, RELAY_OFF, RELAY_SET, HEATER_ON/OFF, FAN_ON/OFF

---

#### `CommandStatus_t CommandReceiver_HandleConfiguration(Command_t *cmd)`

**Описание:** Обработчик команд конфигурации

**Параметры:**
- `cmd` - указатель на команду

**Возвращает:** Статус выполнения

**Поддерживаемые коды:** SET_TEMPERATURE, SET_INTERVAL, SET_MODE

---

#### `CommandStatus_t CommandReceiver_HandleRequest(Command_t *cmd)`

**Описание:** Обработчик команд запроса данных

**Параметры:**
- `cmd` - указатель на команду

**Возвращает:** Статус выполнения

**Поддерживаемые коды:** GET_STATUS, GET_VERSION, GET_CONFIG

**Примечание:** Автоматически отправляет ответ с запрошенными данными

---

### Вспомогательные функции

#### `uint16_t CommandReceiver_CalculateCRC(uint8_t *data, uint16_t length)`

**Описание:** Вычисление CRC16 для массива данных

**Параметры:**
- `data` - указатель на данные
- `length` - длина данных в байтах

**Возвращает:** Значение CRC16

---

#### `uint8_t CommandReceiver_ValidateCRC(uint8_t *data, uint16_t length, uint16_t receivedCRC)`

**Описание:** Проверка CRC16 полученных данных

**Параметры:**
- `data` - указатель на данные (без CRC)
- `length` - длина данных (без CRC)
- `receivedCRC` - полученная контрольная сумма

**Возвращает:** 1 если CRC корректна, 0 если нет

---

## Примеры использования

### Пример 1: Запуск программы

**Команда от сервера:**
```
Байты: 01 01 00 C0 C1
       │  │  │  └─┴─ CRC16
       │  │  └───── Длина данных (0)
       │  └──────── Код команды (START)
       └─────────── Тип команды (PROG_CONTROL)
```

**Ответ контроллера:**
```
Байты: 80 01 00 00 81 80
       │  │  │  │  └─┴─ CRC16
       │  │  │  └───── Длина данных (0)
       │  │  └──────── Статус (OK)
       │  └─────────── Код команды (START)
       └────────────── Тип (RESPONSE)
```

---

### Пример 2: Включение реле №5

**Команда от сервера:**
```
Байты: 04 01 01 05 XX XX
       │  │  │  │  └─┴─ CRC16
       │  │  │  └───── Данные (номер реле = 5)
       │  │  └──────── Длина данных (1)
       │  └─────────── Код команды (RELAY_ON)
       └────────────── Тип команды (DEVICE_CONTROL)
```

**Действия контроллера:**
1. Переключение в ручной режим
2. Установка бита 5 в регистре реле
3. Отправка подтверждения

---

### Пример 3: Запрос статуса

**Команда от сервера:**
```
Байты: 03 01 00 XX XX
       │  │  │  └─┴─ CRC16
       │  │  └───── Длина данных (0)
       │  └──────── Код команды (GET_STATUS)
       └─────────── Тип команды (REQUEST)
```

**Ответ контроллера:**
```
Байты: 80 01 00 02 3C 00 XX XX
       │  │  │  │  │  │  └─┴─ CRC16
       │  │  │  │  └──┴──── Данные (статус = 0x003C)
       │  │  │  └─────────── Длина данных (2)
       │  │  └────────────── Статус (OK)
       │  └───────────────── Код команды (GET_STATUS)
       └──────────────────── Тип (RESPONSE)
```

---

### Пример 4: Установка всех реле

**Команда от сервера:**
```
Байты: 04 03 02 3C 00 XX XX
       │  │  │  │  │  └─┴─ CRC16
       │  │  │  └──┴──── Данные (маска = 0x003C)
       │  │  └─────────── Длина данных (2)
       │  └────────────── Код команды (RELAY_SET)
       └───────────────── Тип команды (DEVICE_CONTROL)
```

**Действия:** Устанавливает реле 2, 3, 4, 5 в ON, остальные в OFF

---

## Обработка ошибок

### Типы ошибок

1. **Ошибка CRC**
   - Обнаружение: При несовпадении вычисленной и полученной CRC
   - Действие: Отправка ответа с кодом CMD_STATUS_CRC_ERROR
   - Статистика: Инкремент счетчика crcErrors

2. **Неверный тип команды**
   - Обнаружение: Тип не входит в список поддерживаемых
   - Действие: Ответ CMD_STATUS_INVALID_TYPE
   - Статистика: Инкремент invalidCommands

3. **Неверный код команды**
   - Обнаружение: Код не поддерживается для данного типа
   - Действие: Ответ CMD_STATUS_INVALID_CODE
   - Статистика: Инкремент executionErrors

4. **Неверная длина данных**
   - Обнаружение: DataLen не соответствует ожидаемому
   - Действие: Ответ CMD_STATUS_INVALID_LENGTH
   - Статистика: Инкремент executionErrors

5. **Таймаут приема**
   - Обнаружение: Семафор не получен в течение 5000 мс
   - Действие: Прерывание приема, переход к следующему циклу
   - Статистика: Не учитывается

### Статистика работы модуля

Модуль ведет внутреннюю статистику:

```cpp
typedef struct {
    uint32_t totalCommandsReceived;   // Всего команд получено
    uint32_t commandsProcessedOK;     // Успешно обработано
    uint32_t crcErrors;               // Ошибки CRC
    uint32_t invalidCommands;         // Недопустимые команды
    uint32_t executionErrors;         // Ошибки выполнения
} CommandStats_t;
```

---

## Конфигурация

### Константы модуля

```cpp
// Длины буферов
#define CMD_MAX_LENGTH 64           // Максимальная длина команды
#define CMD_MAX_DATA_LENGTH 59      // Максимальная длина данных
#define CMD_HEADER_SIZE 3           // Размер заголовка
#define CMD_CRC_SIZE 2              // Размер CRC
```

### Настройка UART4

Конфигурация выполняется в CubeMX:
- Скорость: настраивается (по умолчанию 19200)
- Режим: Asynchronous
- DMA: включен для TX и RX
- Прерывания: включены

### Настройка GPIO

**PROG_MASTER_DE** - управление направлением RS-485:
- HIGH - передача
- LOW - прием

### Настройка FreeRTOS

**Задача CommandReceiver:**
- Приоритет: osPriorityNormal (можно изменить)
- Размер стека: 512 слов (рекомендуется)
- Имя: "CommandReceiver_Task"

**Семафоры:**
- PR_RX_Compl_SemHandle - бинарный семафор
- PR_TX_Compl_SemHandle - бинарный семафор

---

## Диагностика и отладка

### Точки отладки

1. **Прием команды:**
   - Проверьте содержимое `RX_CMD_Buffer` после приема
   - Убедитесь, что длина соответствует ожидаемой

2. **Проверка CRC:**
   - Сравните вычисленную и полученную CRC
   - Проверьте порядок байтов (Little Endian)

3. **Выполнение команды:**
   - Установите breakpoint в соответствующем обработчике
   - Проверьте изменение глобальных переменных (Model::DFR, и т.д.)

4. **Отправка ответа:**
   - Проверьте содержимое `TX_Response_Buffer`
   - Убедитесь, что GPIO DE переключается корректно

### Типичные проблемы

**Проблема:** Команды не принимаются

**Решения:**
- Проверьте скорость UART на обоих сторонах
- Убедитесь, что DE GPIO корректно управляется
- Проверьте подключение RS-485 (A, B, GND)

**Проблема:** Постоянные ошибки CRC

**Решения:**
- Проверьте алгоритм CRC на стороне сервера (ModBus CRC16)
- Убедитесь в правильном порядке байтов
- Проверьте целостность линии связи

**Проблема:** Ответы не доходят до сервера

**Решения:**
- Проверьте задержку перед передачей (osDelay(1))
- Убедитесь, что семафор TX корректно освобождается
- Проверьте таймаут приема на стороне сервера

---

## Расширение функциональности

### Добавление нового типа команд

1. Добавьте новый тип в `CommandType_t` (CommandReceiver.hpp)
2. Создайте enum для кодов команд нового типа
3. Реализуйте обработчик `CommandReceiver_HandleNewType()`
4. Добавьте case в `CommandReceiver_ProcessCommand()`

### Добавление новой команды

1. Добавьте код команды в соответствующий enum
2. Добавьте case в соответствующий обработчик
3. Реализуйте логику обработки команды
4. Обновите документацию

---

## Приложения

### Приложение A: CRC16 ModBus

Используется таблица для ускорения вычислений. Алгоритм совместим с ModBus RTU.

**Полином:** 0xA001  
**Начальное значение:** 0xFFFF

### Приложение Б: Структуры данных

```cpp
// Структура команды
typedef struct {
    uint8_t commandType;
    uint8_t commandCode;
    uint8_t dataLength;
    uint8_t data[CMD_MAX_DATA_LENGTH];
    uint16_t crc;
} Command_t;

// Структура ответа
typedef struct {
    uint8_t commandType;
    uint8_t commandCode;
    uint8_t status;
    uint8_t dataLength;
    uint8_t data[CMD_MAX_DATA_LENGTH];
    uint16_t crc;
} CommandResponse_t;
```

---

## Контактная информация

**Проект:** Defrost Control System  
**Автор модуля:** System  
**Дата создания:** 23 октября 2025  
**Версия документа:** 1.0

---

*Конец документа*

Проверь следующее: направление RS485 на передачу включает только функция передачи данных. Прерывание по окончанию передачи возвращает направление на приём. Функции приёма трогать DE через GPIO не нужно совсем. Но передача должна включаться только тогда, когда нет приёма данных! Нужно проверить состояние приёма UART и разрешать передачу только если нет приёма.
┌────────────────────────────────────────────────────────┐
│                  Инициализация                         │
│  DE = 0 (прием) → Запуск постоянного приема           │
└────────────────────────────────────────────────────────┘
                            ↓
┌────────────────────────────────────────────────────────┐
│                  Постоянный прием                      │
│  UART4 постоянно принимает данные                     │
│  Обработка происходит в прерывании                    │
└────────────────────────────────────────────────────────┘
                            ↓
           Нужно отправить ответ?
                            ↓
┌────────────────────────────────────────────────────────┐
│              Проверка состояния UART                   │
│  Ждем пока UART_STATE == READY (нет приема)           │
└────────────────────────────────────────────────────────┘
                            ↓
┌────────────────────────────────────────────────────────┐
│                     Передача                           │
│  1. DE = 1 (передача)                                 │
│  2. Передача данных                                   │
│  3. Прерывание TxCplt → DE = 0 (прием)               │
└────────────────────────────────────────────────────────┘
                            ↓
              Возврат к постоянному приему
================================================================================

Сервер → UART4 → DMA → Прерывание RxEvent
                              ↓
                    Сохранить размер
                              ↓
                    Освободить семафор
                              ↓
                    Перезапустить прием
                              ↓
                         (выход из прерывания)
                              
                              ↓
        Поток RX_From_ServerHandle просыпается
                              ↓
        Обрабатывает команду (долго, сложно)
                              ↓
        Отправляет ответ (если нужно)
                              ↓
        Засыпает в ожидании следующего семафора