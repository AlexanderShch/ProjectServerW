ДОБАВЛЕНА ПОДДЕРЖКА SYNC-МАРКЕРОВ В ПРОТОКОЛЕ (ОДНОСТОРОННЯЯ)
=================================================================

Изменения: Только контроллер ? сервер
==========================================

## SYNC-МАРКЕРЫ:

```
SYNC_START = 0xAA 0x55  (начало пакета)
SYNC_END   = 0x55 0xAA  (конец пакета)
```

## СТРУКТУРА ПАКЕТОВ С МАРКЕРАМИ:

### 1. Телеметрия (Type=0x00):
```
БЫЛО: [Type][42 байта данных][CRC] = 48 байт
СТАЛО: [AA 55][Type][42 байта данных][CRC][55 AA] = 52 байта
```

### 2. Ответы на команды (Type=0x01-0x04):
```
БЫЛО: [Type][Code][Status][DataLen][Data...][CRC] = 6-256 байт
СТАЛО: [AA 55][Type][Code][Status][DataLen][Data...][CRC][55 AA] = 10-260 байт
```

### 3. Команды от сервера (БЕЗ ИЗМЕНЕНИЙ):
```
[Type][Code][DataLen][Data...][CRC] - остаётся как было
```

================================================================================
КОД ДЛЯ КОНТРОЛЛЕРА (Си)
================================================================================

```c
// ===== Константы =====
#define SYNC_START_1  0xAA
#define SYNC_START_2  0x55
#define SYNC_END_1    0x55
#define SYNC_END_2    0xAA

// ===== Функция отправки с sync-маркерами =====
void SendPacketToServer(uint8_t* packet, uint16_t length) {
    uint8_t sync_start[2] = {SYNC_START_1, SYNC_START_2};
    uint8_t sync_end[2] = {SYNC_END_1, SYNC_END_2};
    
    // Отправка sync_start
    UART_Send(sync_start, 2);
    
    // Отправка данных пакета (Type + Data + CRC)
    UART_Send(packet, length);
    
    // Отправка sync_end
    UART_Send(sync_end, 2);
}

// ===== Пример 1: Отправка телеметрии =====
void SendTelemetry(TelemetryData_t* telemetry) {
    uint8_t packet[48];
    
    // Формирование пакета
    packet[0] = 0x00;  // Type = телеметрия
    memcpy(&packet[1], telemetry, 44);  // Данные (44 байта)
    
    // Вычисление CRC для первых 46 байт
    uint16_t crc = CalculateCRC16(packet, 46);
    memcpy(&packet[46], &crc, 2);
    
    // Отправка с sync-маркерами
    SendPacketToServer(packet, 48);
    // Итого будет отправлено: AA 55 [48 байт] 55 AA = 52 байта
}

// ===== Пример 2: Отправка ответа на команду =====
void SendCommandResponse(uint8_t type, uint8_t code, uint8_t status,
                        uint8_t* data, uint8_t dataLen) {
    uint8_t packet[256];
    
    // Формирование пакета
    packet[0] = type;
    packet[1] = code;
    packet[2] = status;
    packet[3] = dataLen;
    
    if (dataLen > 0 && data != NULL) {
        memcpy(&packet[4], data, dataLen);
    }
    
    // Вычисление CRC
    uint16_t packetSize = 4 + dataLen;
    uint16_t crc = CalculateCRC16(packet, packetSize);
    memcpy(&packet[packetSize], &crc, 2);
    
    // Отправка с sync-маркерами
    SendPacketToServer(packet, packetSize + 2);
    // Итого: AA 55 [Type+Code+Status+DataLen+Data+CRC] 55 AA
}

// ===== Пример 3: Приём команд от сервера (БЕЗ ИЗМЕНЕНИЙ) =====
void ReceiveCommand() {
    uint8_t packet[256];
    uint16_t length = 0;
    
    // Читаем как раньше (без sync-маркеров)
    packet[0] = UART_ReadByte();  // Type
    packet[1] = UART_ReadByte();  // Code
    packet[2] = UART_ReadByte();  // DataLen
    uint8_t dataLen = packet[2];
    
    // Читаем остальные данные
    for (int i = 0; i < dataLen; i++) {
        packet[3 + i] = UART_ReadByte();
    }
    
    // Читаем CRC (2 байта)
    packet[3 + dataLen] = UART_ReadByte();
    packet[4 + dataLen] = UART_ReadByte();
    
    // Проверка CRC и обработка команды
    ProcessCommand(packet, 5 + dataLen);
}
```

================================================================================
ИЗМЕНЕНИЯ НА СЕРВЕРЕ
================================================================================

## Добавлено в SServer.cpp:

### 1. Константы sync-маркеров:
```cpp
const uint8_t SYNC_START_1 = 0xAA;
const uint8_t SYNC_START_2 = 0x55;
const uint8_t SYNC_END_1   = 0x55;
const uint8_t SYNC_END_2   = 0xAA;
```

### 2. Функции проверки sync-маркеров:
- `HasSyncMarkers()` - проверка наличия sync_start
- `FindSyncMarker()` - поиск sync_start в буфере
- `CheckSyncEnd()` - проверка sync_end

### 3. Автоопределение режима:
```cpp
enum ProtocolMode { MODE_UNKNOWN, MODE_WITH_SYNC, MODE_WITHOUT_SYNC };
```

При получении первого пакета сервер автоматически определяет:
- Если начинается с `AA 55` ? режим WITH_SYNC
- Иначе ? режим WITHOUT_SYNC (старый протокол)

### 4. Логика обработки:

**Режим WITH_SYNC (новый протокол):**
1. Ищет `AA 55` в начале
2. Определяет тип и размер пакета
3. Проверяет наличие `55 AA` в конце
4. Извлекает данные между маркерами
5. Проверяет CRC
6. При ошибке пропускает пакет и ищет следующий sync

**Режим WITHOUT_SYNC (старый протокол):**
- Работает как раньше (обратная совместимость)

================================================================================
ПРЕИМУЩЕСТВА
================================================================================

? **Надёжное восстановление** после ошибок CRC
? **Быстрый поиск** начала пакета при сбоях
? **Двойная проверка** целостности (sync + CRC)
? **Обратная совместимость** со старым контроллером
? **Автоопределение** режима без настроек
? **Визуальная отладка** - легко найти границы пакетов в hex-дампе

================================================================================
ТЕСТИРОВАНИЕ
================================================================================

1. **Со старым контроллером:**
   - Сервер автоматически определит MODE_WITHOUT_SYNC
   - Всё работает как раньше

2. **С новым контроллером:**
   - Сервер автоматически определит MODE_WITH_SYNC
   - В логе появится: "[SYNC] Обнаружен новый протокол с sync-маркерами (AA 55)"
   
3. **При ошибках:**
   - Старый протокол: "[ОШИБКА CRC] Expected=..., пропускаем пакет"
   - Новый протокол: "[SYNC] Нет sync_end, ищем следующий пакет"

================================================================================
НАКЛАДНЫЕ РАСХОДЫ
================================================================================

| Пакет | Было | Стало | +Байт | +% |
|-------|------|-------|-------|-----|
| Телеметрия | 48 | 52 | +4 | +8% |
| Ответ (мин) | 6 | 10 | +4 | +67% |
| Ответ (макс) | 256 | 260 | +4 | +1.5% |

**Вывод:** Минимальные накладные расходы (+4 байта на пакет)

